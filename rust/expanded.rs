#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
mod lib_inner {
    //mod expanded;
    use pyo3::{
        pyclass, pyfunction, pymethods, pymodule, types::PyModule, wrap_pyfunction, PyResult,
        Python,
    };
    fn py_compnet(_py: Python<'_>, m: &PyModule) -> PyResult<()> {
        m.add_class::<SimpleStruct>()?;
        m.add_class::<DayOfTheWeek>()?;
        m.add_class::<ComplexEnum>()?;
        m.add_wrapped(
            &(|py_or_module| {
                use do_stuff as wrapped_pyfunction;
                ::pyo3::impl_::pyfunction::_wrap_pyfunction(&wrapped_pyfunction::DEF, py_or_module)
            }),
        )?;
        Ok(())
    }
    #[doc(hidden)]
    mod py_compnet {
        pub(crate) struct MakeDef;
        pub static DEF: ::pyo3::impl_::pymodule::ModuleDef = MakeDef::make_def();
        pub const NAME: &'static str = "adt_stuff\u{0}";
        #[doc = r" This autogenerated function is called by the python interpreter when importing"]
        #[doc = r" the module."]
        #[export_name = "PyInit_adt_stuff"]
        pub unsafe extern "C" fn init() -> *mut ::pyo3::ffi::PyObject {
            ::pyo3::impl_::trampoline::module_init(|py| DEF.make_module(py))
        }
    }
    const _: () = {
        use pyo3::impl_::pymodule as impl_;
        impl py_compnet::MakeDef {
            const fn make_def() -> impl_::ModuleDef {
                const INITIALIZER: impl_::ModuleInitializer = impl_::ModuleInitializer(py_compnet);
                unsafe { impl_::ModuleDef::new(py_compnet::NAME, "\0", INITIALIZER) }
            }
        }
    };
    pub struct SimpleStruct {
        pub i: i32,
        pub f: f64,
        pub s: String,
    }
    const _: () = {
        use pyo3 as _pyo3;
        unsafe impl _pyo3::type_object::PyTypeInfo for SimpleStruct {
            type AsRefTarget = _pyo3::PyCell<Self>;
            const NAME: &'static str = "SimpleStruct";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(py: _pyo3::Python<'_>) -> *mut _pyo3::ffi::PyTypeObject {
                <SimpleStruct as _pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        impl _pyo3::PyClass for SimpleStruct {
            type Frozen = _pyo3::pyclass::boolean_struct::False;
        }
        impl<'a, 'py> _pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py> for &'a SimpleStruct {
            type Holder = ::std::option::Option<_pyo3::PyRef<'py, SimpleStruct>>;
            #[inline]
            fn extract(
                obj: &'py _pyo3::PyAny,
                holder: &'a mut Self::Holder,
            ) -> _pyo3::PyResult<Self> {
                _pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl<'a, 'py> _pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py> for &'a mut SimpleStruct {
            type Holder = ::std::option::Option<_pyo3::PyRefMut<'py, SimpleStruct>>;
            #[inline]
            fn extract(
                obj: &'py _pyo3::PyAny,
                holder: &'a mut Self::Holder,
            ) -> _pyo3::PyResult<Self> {
                _pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
            }
        }
        impl _pyo3::IntoPy<_pyo3::PyObject> for SimpleStruct {
            fn into_py(self, py: _pyo3::Python) -> _pyo3::PyObject {
                _pyo3::IntoPy::into_py(_pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        impl _pyo3::impl_::pyclass::PyClassImpl for SimpleStruct {
            const IS_BASETYPE: bool = false;
            const IS_SUBCLASS: bool = false;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type BaseType = _pyo3::PyAny;
            type ThreadChecker = _pyo3::impl_::pyclass::SendablePyClass<SimpleStruct>;
            type PyClassMutability =
                    <<_pyo3::PyAny as
                    _pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability
                    as _pyo3::impl_::pycell::PyClassMutability>::MutableChild;
            type Dict = _pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = _pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType = _pyo3::PyAny;
            fn items_iter() -> _pyo3::impl_::pyclass::PyClassItemsIter {
                use _pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[],
                    slots: &[],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(py: _pyo3::Python<'_>) -> _pyo3::PyResult<&'static ::std::ffi::CStr> {
                use _pyo3::impl_::pyclass::*;
                static DOC: _pyo3::once_cell::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = _pyo3::once_cell::GILOnceCell::new();
                DOC.get_or_try_init(py, || {
                    let collector = PyClassImplCollector::<Self>::new();
                    build_pyclass_doc(
                        <SimpleStruct as _pyo3::PyTypeInfo>::NAME,
                        "\0",
                        ::std::option::Option::None.or_else(|| collector.new_text_signature()),
                    )
                })
                .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static _pyo3::impl_::pyclass::LazyTypeObject<Self> {
                use _pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<SimpleStruct> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl SimpleStruct {}
    };
    impl SimpleStruct {
        fn new(i: i32, f: f64, s: String) -> Self {
            Self { i, f, s }
        }
    }
    const _: () = {
        use pyo3 as _pyo3;
        impl _pyo3::impl_::pyclass::PyMethods<SimpleStruct>
            for _pyo3::impl_::pyclass::PyClassImplCollector<SimpleStruct>
        {
            fn py_methods(self) -> &'static _pyo3::impl_::pyclass::PyClassItems {
                static ITEMS: _pyo3::impl_::pyclass::PyClassItems =
                    _pyo3::impl_::pyclass::PyClassItems {
                        methods: &[],
                        slots: &[_pyo3::ffi::PyType_Slot {
                            slot: _pyo3::ffi::Py_tp_new,
                            pfunc: {
                                unsafe extern "C" fn trampoline(
                                    subtype: *mut _pyo3::ffi::PyTypeObject,
                                    args: *mut _pyo3::ffi::PyObject,
                                    kwargs: *mut _pyo3::ffi::PyObject,
                                ) -> *mut _pyo3::ffi::PyObject {
                                    use _pyo3::impl_::pyclass::*;
                                    impl PyClassNewTextSignature<SimpleStruct> for PyClassImplCollector<SimpleStruct> {
                                        #[inline]
                                        fn new_text_signature(
                                            self,
                                        ) -> ::std::option::Option<&'static str>
                                        {
                                            ::std::option::Option::Some("(i, f, s)")
                                        }
                                    }
                                    _pyo3::impl_::trampoline::newfunc(
                                        subtype,
                                        args,
                                        kwargs,
                                        SimpleStruct::__pymethod___new____,
                                    )
                                }
                                trampoline
                            } as _pyo3::ffi::newfunc as _,
                        }],
                    };
                &ITEMS
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl SimpleStruct {
            unsafe fn __pymethod___new____(
                py: _pyo3::Python<'_>,
                subtype: *mut _pyo3::ffi::PyTypeObject,
                _args: *mut _pyo3::ffi::PyObject,
                _kwargs: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                use _pyo3::callback::IntoPyCallbackOutput;
                let function = SimpleStruct::new;
                const DESCRIPTION: _pyo3::impl_::extract_argument::FunctionDescription =
                    _pyo3::impl_::extract_argument::FunctionDescription {
                        cls_name: ::std::option::Option::Some(
                            <SimpleStruct as _pyo3::type_object::PyTypeInfo>::NAME,
                        ),
                        func_name: "__new__",
                        positional_parameter_names: &["i", "f", "s"],
                        positional_only_parameters: 0usize,
                        required_positional_parameters: 3usize,
                        keyword_only_parameters: &[],
                    };
                let mut output = [::std::option::Option::None; 3usize];
                let (_args, _kwargs) =
                        DESCRIPTION.extract_arguments_tuple_dict::<_pyo3::impl_::extract_argument::NoVarargs,
                                _pyo3::impl_::extract_argument::NoVarkeywords>(py, _args,
                                _kwargs, &mut output)?;
                let result = SimpleStruct::new(
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(output[0usize]),
                        &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                        "i",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(output[1usize]),
                        &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                        "f",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(output[2usize]),
                        &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                        "s",
                    )?,
                );
                let initializer: _pyo3::PyClassInitializer<SimpleStruct> = result.convert(py)?;
                let cell = initializer.create_cell_from_subtype(py, subtype)?;
                ::std::result::Result::Ok(cell as *mut _pyo3::ffi::PyObject)
            }
        }
    };
    pub enum ComplexEnum {
        Int { i: i32 },
        Float { f: f64 },
        Str { s: String },
    }
    const _: () = {
        use pyo3 as _pyo3;
        unsafe impl _pyo3::type_object::PyTypeInfo for ComplexEnum {
            type AsRefTarget = _pyo3::PyCell<Self>;
            const NAME: &'static str = "ComplexEnum";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(py: _pyo3::Python<'_>) -> *mut _pyo3::ffi::PyTypeObject {
                <ComplexEnum as _pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        impl _pyo3::PyClass for ComplexEnum {
            type Frozen = _pyo3::pyclass::boolean_struct::False;
        }
        impl<'a, 'py> _pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py> for &'a ComplexEnum {
            type Holder = ::std::option::Option<_pyo3::PyRef<'py, ComplexEnum>>;
            #[inline]
            fn extract(
                obj: &'py _pyo3::PyAny,
                holder: &'a mut Self::Holder,
            ) -> _pyo3::PyResult<Self> {
                _pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl<'a, 'py> _pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py> for &'a mut ComplexEnum {
            type Holder = ::std::option::Option<_pyo3::PyRefMut<'py, ComplexEnum>>;
            #[inline]
            fn extract(
                obj: &'py _pyo3::PyAny,
                holder: &'a mut Self::Holder,
            ) -> _pyo3::PyResult<Self> {
                _pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
            }
        }
        impl _pyo3::IntoPy<_pyo3::PyObject> for ComplexEnum {
            fn into_py(self, py: _pyo3::Python) -> _pyo3::PyObject {
                _pyo3::IntoPy::into_py(_pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        impl _pyo3::impl_::pyclass::PyClassImpl for ComplexEnum {
            const IS_BASETYPE: bool = false;
            const IS_SUBCLASS: bool = false;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type BaseType = _pyo3::PyAny;
            type ThreadChecker = _pyo3::impl_::pyclass::SendablePyClass<ComplexEnum>;
            type PyClassMutability =
                    <<_pyo3::PyAny as
                    _pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability
                    as _pyo3::impl_::pycell::PyClassMutability>::MutableChild;
            type Dict = _pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = _pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType = _pyo3::PyAny;
            fn items_iter() -> _pyo3::impl_::pyclass::PyClassItemsIter {
                use _pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[
                        _pyo3::class::PyMethodDefType::ClassAttribute({
                            _pyo3::class::PyClassAttributeDef::new(
                                { "Int\0" },
                                _pyo3::impl_::pymethods::PyClassAttributeFactory(
                                    ComplexEnum::__pymethod_variant_cls_Int__,
                                ),
                            )
                        }),
                        _pyo3::class::PyMethodDefType::ClassAttribute({
                            _pyo3::class::PyClassAttributeDef::new(
                                { "Float\0" },
                                _pyo3::impl_::pymethods::PyClassAttributeFactory(
                                    ComplexEnum::__pymethod_variant_cls_Float__,
                                ),
                            )
                        }),
                        _pyo3::class::PyMethodDefType::ClassAttribute({
                            _pyo3::class::PyClassAttributeDef::new(
                                { "Str\0" },
                                _pyo3::impl_::pymethods::PyClassAttributeFactory(
                                    ComplexEnum::__pymethod_variant_cls_Str__,
                                ),
                            )
                        }),
                    ],
                    slots: &[],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(py: _pyo3::Python<'_>) -> _pyo3::PyResult<&'static ::std::ffi::CStr> {
                use _pyo3::impl_::pyclass::*;
                static DOC: _pyo3::once_cell::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = _pyo3::once_cell::GILOnceCell::new();
                DOC.get_or_try_init(py, || {
                    let collector = PyClassImplCollector::<Self>::new();
                    build_pyclass_doc(
                        <ComplexEnum as _pyo3::PyTypeInfo>::NAME,
                        "\0",
                        ::std::option::Option::None.or_else(|| collector.new_text_signature()),
                    )
                })
                .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static _pyo3::impl_::pyclass::LazyTypeObject<Self> {
                use _pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<ComplexEnum> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ComplexEnum {
            fn __pymethod_variant_cls_Int__(
                py: _pyo3::Python<'_>,
            ) -> _pyo3::PyResult<_pyo3::PyObject> {
                ::std::result::Result::Ok(py.get_type::<ComplexEnum_Int>().into())
            }
            fn __pymethod_variant_cls_Float__(
                py: _pyo3::Python<'_>,
            ) -> _pyo3::PyResult<_pyo3::PyObject> {
                ::std::result::Result::Ok(py.get_type::<ComplexEnum_Float>().into())
            }
            fn __pymethod_variant_cls_Str__(
                py: _pyo3::Python<'_>,
            ) -> _pyo3::PyResult<_pyo3::PyObject> {
                ::std::result::Result::Ok(py.get_type::<ComplexEnum_Str>().into())
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ComplexEnum {}
        #[doc(hidden)]
        #[allow(non_camel_case_types)]
        struct ComplexEnum_Int;
        impl _pyo3::IntoPy<_pyo3::PyObject> for ComplexEnum_Int {
            fn into_py(self, py: _pyo3::Python) -> _pyo3::PyObject {
                _pyo3::IntoPy::into_py(_pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        #[doc(hidden)]
        #[allow(non_camel_case_types)]
        struct ComplexEnum_Float;
        impl _pyo3::IntoPy<_pyo3::PyObject> for ComplexEnum_Float {
            fn into_py(self, py: _pyo3::Python) -> _pyo3::PyObject {
                _pyo3::IntoPy::into_py(_pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        #[doc(hidden)]
        #[allow(non_camel_case_types)]
        struct ComplexEnum_Str;
        impl _pyo3::IntoPy<_pyo3::PyObject> for ComplexEnum_Str {
            fn into_py(self, py: _pyo3::Python) -> _pyo3::PyObject {
                _pyo3::IntoPy::into_py(_pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        unsafe impl _pyo3::type_object::PyTypeInfo for ComplexEnum_Int {
            type AsRefTarget = _pyo3::PyCell<Self>;
            const NAME: &'static str = "ComplexEnum_Int";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(py: _pyo3::Python<'_>) -> *mut _pyo3::ffi::PyTypeObject {
                <ComplexEnum_Int as _pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        unsafe impl _pyo3::type_object::PyTypeInfo for ComplexEnum_Float {
            type AsRefTarget = _pyo3::PyCell<Self>;
            const NAME: &'static str = "ComplexEnum_Float";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(py: _pyo3::Python<'_>) -> *mut _pyo3::ffi::PyTypeObject {
                <ComplexEnum_Float as _pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        unsafe impl _pyo3::type_object::PyTypeInfo for ComplexEnum_Str {
            type AsRefTarget = _pyo3::PyCell<Self>;
            const NAME: &'static str = "ComplexEnum_Str";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(py: _pyo3::Python<'_>) -> *mut _pyo3::ffi::PyTypeObject {
                <ComplexEnum_Str as _pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        impl _pyo3::PyClass for ComplexEnum_Int {
            type Frozen = _pyo3::pyclass::boolean_struct::True;
        }
        impl<'a, 'py> _pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py> for &'a ComplexEnum_Int {
            type Holder = ::std::option::Option<_pyo3::PyRef<'py, ComplexEnum_Int>>;
            #[inline]
            fn extract(
                obj: &'py _pyo3::PyAny,
                holder: &'a mut Self::Holder,
            ) -> _pyo3::PyResult<Self> {
                _pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl _pyo3::impl_::pyclass::PyClassImpl for ComplexEnum_Int {
            const IS_BASETYPE: bool = false;
            const IS_SUBCLASS: bool = true;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type BaseType = ComplexEnum;
            type ThreadChecker = _pyo3::impl_::pyclass::SendablePyClass<ComplexEnum_Int>;
            type PyClassMutability =
                    <<ComplexEnum as
                    _pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability
                    as _pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
            type Dict = _pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = _pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType =
                <Self::BaseType as _pyo3::impl_::pyclass::PyClassBaseType>::BaseNativeType;
            fn items_iter() -> _pyo3::impl_::pyclass::PyClassItemsIter {
                use _pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[_pyo3::class::PyMethodDefType::Getter(
                        _pyo3::class::PyGetterDef::new(
                            "i\0",
                            _pyo3::impl_::pymethods::PyGetter(ComplexEnum_Int::__pymethod_get_i__),
                            "\0",
                        ),
                    )],
                    slots: &[_pyo3::ffi::PyType_Slot {
                        slot: _pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut _pyo3::ffi::PyTypeObject,
                                args: *mut _pyo3::ffi::PyObject,
                                kwargs: *mut _pyo3::ffi::PyObject,
                            ) -> *mut _pyo3::ffi::PyObject {
                                use _pyo3::impl_::pyclass::*;
                                impl PyClassNewTextSignature<ComplexEnum_Int> for PyClassImplCollector<ComplexEnum_Int> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str>
                                    {
                                        ::std::option::Option::Some("(i)")
                                    }
                                }
                                _pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    ComplexEnum_Int::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as _pyo3::ffi::newfunc as _,
                    }],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(py: _pyo3::Python<'_>) -> _pyo3::PyResult<&'static ::std::ffi::CStr> {
                use _pyo3::impl_::pyclass::*;
                static DOC: _pyo3::once_cell::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = _pyo3::once_cell::GILOnceCell::new();
                DOC.get_or_try_init(py, || {
                    let collector = PyClassImplCollector::<Self>::new();
                    build_pyclass_doc(
                        <ComplexEnum_Int as _pyo3::PyTypeInfo>::NAME,
                        "\0",
                        ::std::option::Option::None.or_else(|| collector.new_text_signature()),
                    )
                })
                .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static _pyo3::impl_::pyclass::LazyTypeObject<Self> {
                use _pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<ComplexEnum_Int> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ComplexEnum_Int {
            unsafe fn __pymethod_get_i__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::callback::convert(
                    py,
                    ComplexEnum_Int::i(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                        ComplexEnum_Int,
                    >(
                        py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                        &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                    )?),
                )
            }
            unsafe fn __pymethod___new____(
                py: _pyo3::Python<'_>,
                subtype: *mut _pyo3::ffi::PyTypeObject,
                _args: *mut _pyo3::ffi::PyObject,
                _kwargs: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                use _pyo3::callback::IntoPyCallbackOutput;
                let function = ComplexEnum_Int::__pymethod_constructor__;
                const DESCRIPTION: _pyo3::impl_::extract_argument::FunctionDescription =
                    _pyo3::impl_::extract_argument::FunctionDescription {
                        cls_name: ::std::option::Option::Some(
                            <ComplexEnum_Int as _pyo3::type_object::PyTypeInfo>::NAME,
                        ),
                        func_name: "__new__",
                        positional_parameter_names: &["i"],
                        positional_only_parameters: 0usize,
                        required_positional_parameters: 1usize,
                        keyword_only_parameters: &[],
                    };
                let mut output = [::std::option::Option::None; 1usize];
                let (_args, _kwargs) =
                        DESCRIPTION.extract_arguments_tuple_dict::<_pyo3::impl_::extract_argument::NoVarargs,
                                _pyo3::impl_::extract_argument::NoVarkeywords>(py, _args,
                                _kwargs, &mut output)?;
                let result = ComplexEnum_Int::__pymethod_constructor__(
                    py,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(output[0usize]),
                        &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                        "i",
                    )?,
                );
                let initializer: _pyo3::PyClassInitializer<ComplexEnum_Int> = result.convert(py)?;
                let cell = initializer.create_cell_from_subtype(py, subtype)?;
                ::std::result::Result::Ok(cell as *mut _pyo3::ffi::PyObject)
            }
        }
        impl _pyo3::PyClass for ComplexEnum_Float {
            type Frozen = _pyo3::pyclass::boolean_struct::True;
        }
        impl<'a, 'py> _pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
            for &'a ComplexEnum_Float
        {
            type Holder = ::std::option::Option<_pyo3::PyRef<'py, ComplexEnum_Float>>;
            #[inline]
            fn extract(
                obj: &'py _pyo3::PyAny,
                holder: &'a mut Self::Holder,
            ) -> _pyo3::PyResult<Self> {
                _pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl _pyo3::impl_::pyclass::PyClassImpl for ComplexEnum_Float {
            const IS_BASETYPE: bool = false;
            const IS_SUBCLASS: bool = true;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type BaseType = ComplexEnum;
            type ThreadChecker = _pyo3::impl_::pyclass::SendablePyClass<ComplexEnum_Float>;
            type PyClassMutability =
                    <<ComplexEnum as
                    _pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability
                    as _pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
            type Dict = _pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = _pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType =
                <Self::BaseType as _pyo3::impl_::pyclass::PyClassBaseType>::BaseNativeType;
            fn items_iter() -> _pyo3::impl_::pyclass::PyClassItemsIter {
                use _pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[_pyo3::class::PyMethodDefType::Getter(
                        _pyo3::class::PyGetterDef::new(
                            "f\0",
                            _pyo3::impl_::pymethods::PyGetter(
                                ComplexEnum_Float::__pymethod_get_f__,
                            ),
                            "\0",
                        ),
                    )],
                    slots: &[_pyo3::ffi::PyType_Slot {
                        slot: _pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut _pyo3::ffi::PyTypeObject,
                                args: *mut _pyo3::ffi::PyObject,
                                kwargs: *mut _pyo3::ffi::PyObject,
                            ) -> *mut _pyo3::ffi::PyObject {
                                use _pyo3::impl_::pyclass::*;
                                impl PyClassNewTextSignature<ComplexEnum_Float> for PyClassImplCollector<ComplexEnum_Float> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str>
                                    {
                                        ::std::option::Option::Some("(f)")
                                    }
                                }
                                _pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    ComplexEnum_Float::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as _pyo3::ffi::newfunc as _,
                    }],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(py: _pyo3::Python<'_>) -> _pyo3::PyResult<&'static ::std::ffi::CStr> {
                use _pyo3::impl_::pyclass::*;
                static DOC: _pyo3::once_cell::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = _pyo3::once_cell::GILOnceCell::new();
                DOC.get_or_try_init(py, || {
                    let collector = PyClassImplCollector::<Self>::new();
                    build_pyclass_doc(
                        <ComplexEnum_Float as _pyo3::PyTypeInfo>::NAME,
                        "\0",
                        ::std::option::Option::None.or_else(|| collector.new_text_signature()),
                    )
                })
                .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static _pyo3::impl_::pyclass::LazyTypeObject<Self> {
                use _pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<ComplexEnum_Float> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ComplexEnum_Float {
            unsafe fn __pymethod_get_f__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::callback::convert(
                    py,
                    ComplexEnum_Float::f(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                        ComplexEnum_Float,
                    >(
                        py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                        &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                    )?),
                )
            }
            unsafe fn __pymethod___new____(
                py: _pyo3::Python<'_>,
                subtype: *mut _pyo3::ffi::PyTypeObject,
                _args: *mut _pyo3::ffi::PyObject,
                _kwargs: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                use _pyo3::callback::IntoPyCallbackOutput;
                let function = ComplexEnum_Float::__pymethod_constructor__;
                const DESCRIPTION: _pyo3::impl_::extract_argument::FunctionDescription =
                    _pyo3::impl_::extract_argument::FunctionDescription {
                        cls_name: ::std::option::Option::Some(
                            <ComplexEnum_Float as _pyo3::type_object::PyTypeInfo>::NAME,
                        ),
                        func_name: "__new__",
                        positional_parameter_names: &["f"],
                        positional_only_parameters: 0usize,
                        required_positional_parameters: 1usize,
                        keyword_only_parameters: &[],
                    };
                let mut output = [::std::option::Option::None; 1usize];
                let (_args, _kwargs) =
                        DESCRIPTION.extract_arguments_tuple_dict::<_pyo3::impl_::extract_argument::NoVarargs,
                                _pyo3::impl_::extract_argument::NoVarkeywords>(py, _args,
                                _kwargs, &mut output)?;
                let result = ComplexEnum_Float::__pymethod_constructor__(
                    py,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(output[0usize]),
                        &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                        "f",
                    )?,
                );
                let initializer: _pyo3::PyClassInitializer<ComplexEnum_Float> =
                    result.convert(py)?;
                let cell = initializer.create_cell_from_subtype(py, subtype)?;
                ::std::result::Result::Ok(cell as *mut _pyo3::ffi::PyObject)
            }
        }
        impl _pyo3::PyClass for ComplexEnum_Str {
            type Frozen = _pyo3::pyclass::boolean_struct::True;
        }
        impl<'a, 'py> _pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py> for &'a ComplexEnum_Str {
            type Holder = ::std::option::Option<_pyo3::PyRef<'py, ComplexEnum_Str>>;
            #[inline]
            fn extract(
                obj: &'py _pyo3::PyAny,
                holder: &'a mut Self::Holder,
            ) -> _pyo3::PyResult<Self> {
                _pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl _pyo3::impl_::pyclass::PyClassImpl for ComplexEnum_Str {
            const IS_BASETYPE: bool = false;
            const IS_SUBCLASS: bool = true;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type BaseType = ComplexEnum;
            type ThreadChecker = _pyo3::impl_::pyclass::SendablePyClass<ComplexEnum_Str>;
            type PyClassMutability =
                    <<ComplexEnum as
                    _pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability
                    as _pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
            type Dict = _pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = _pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType =
                <Self::BaseType as _pyo3::impl_::pyclass::PyClassBaseType>::BaseNativeType;
            fn items_iter() -> _pyo3::impl_::pyclass::PyClassItemsIter {
                use _pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[_pyo3::class::PyMethodDefType::Getter(
                        _pyo3::class::PyGetterDef::new(
                            "s\0",
                            _pyo3::impl_::pymethods::PyGetter(ComplexEnum_Str::__pymethod_get_s__),
                            "\0",
                        ),
                    )],
                    slots: &[_pyo3::ffi::PyType_Slot {
                        slot: _pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut _pyo3::ffi::PyTypeObject,
                                args: *mut _pyo3::ffi::PyObject,
                                kwargs: *mut _pyo3::ffi::PyObject,
                            ) -> *mut _pyo3::ffi::PyObject {
                                use _pyo3::impl_::pyclass::*;
                                impl PyClassNewTextSignature<ComplexEnum_Str> for PyClassImplCollector<ComplexEnum_Str> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str>
                                    {
                                        ::std::option::Option::Some("(s)")
                                    }
                                }
                                _pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    ComplexEnum_Str::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as _pyo3::ffi::newfunc as _,
                    }],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(py: _pyo3::Python<'_>) -> _pyo3::PyResult<&'static ::std::ffi::CStr> {
                use _pyo3::impl_::pyclass::*;
                static DOC: _pyo3::once_cell::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = _pyo3::once_cell::GILOnceCell::new();
                DOC.get_or_try_init(py, || {
                    let collector = PyClassImplCollector::<Self>::new();
                    build_pyclass_doc(
                        <ComplexEnum_Str as _pyo3::PyTypeInfo>::NAME,
                        "\0",
                        ::std::option::Option::None.or_else(|| collector.new_text_signature()),
                    )
                })
                .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static _pyo3::impl_::pyclass::LazyTypeObject<Self> {
                use _pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<ComplexEnum_Str> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ComplexEnum_Str {
            unsafe fn __pymethod_get_s__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::callback::convert(
                    py,
                    ComplexEnum_Str::s(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                        ComplexEnum_Str,
                    >(
                        py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                        &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                    )?),
                )
            }
            unsafe fn __pymethod___new____(
                py: _pyo3::Python<'_>,
                subtype: *mut _pyo3::ffi::PyTypeObject,
                _args: *mut _pyo3::ffi::PyObject,
                _kwargs: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                use _pyo3::callback::IntoPyCallbackOutput;
                let function = ComplexEnum_Str::__pymethod_constructor__;
                const DESCRIPTION: _pyo3::impl_::extract_argument::FunctionDescription =
                    _pyo3::impl_::extract_argument::FunctionDescription {
                        cls_name: ::std::option::Option::Some(
                            <ComplexEnum_Str as _pyo3::type_object::PyTypeInfo>::NAME,
                        ),
                        func_name: "__new__",
                        positional_parameter_names: &["s"],
                        positional_only_parameters: 0usize,
                        required_positional_parameters: 1usize,
                        keyword_only_parameters: &[],
                    };
                let mut output = [::std::option::Option::None; 1usize];
                let (_args, _kwargs) =
                        DESCRIPTION.extract_arguments_tuple_dict::<_pyo3::impl_::extract_argument::NoVarargs,
                                _pyo3::impl_::extract_argument::NoVarkeywords>(py, _args,
                                _kwargs, &mut output)?;
                let result = ComplexEnum_Str::__pymethod_constructor__(
                    py,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(output[0usize]),
                        &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                        "s",
                    )?,
                );
                let initializer: _pyo3::PyClassInitializer<ComplexEnum_Str> = result.convert(py)?;
                let cell = initializer.create_cell_from_subtype(py, subtype)?;
                ::std::result::Result::Ok(cell as *mut _pyo3::ffi::PyObject)
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ComplexEnum_Int {
            fn __pymethod_constructor__(py: _pyo3::Python<'_>, i: i32) -> _pyo3::PyObject {
                use _pyo3::IntoPy;
                ComplexEnum::Int { i }.into_py(py)
            }
            fn i(slf: _pyo3::PyRef<Self>) -> _pyo3::PyResult<i32> {
                match &*slf.into_super() {
                    ComplexEnum::Int { i, .. } => Ok(i.clone()),
                    _ => {
                        ::core::panicking::panic_fmt(format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass"
                            )
                        ));
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ComplexEnum_Float {
            fn __pymethod_constructor__(py: _pyo3::Python<'_>, f: f64) -> _pyo3::PyObject {
                use _pyo3::IntoPy;
                ComplexEnum::Float { f }.into_py(py)
            }
            fn f(slf: _pyo3::PyRef<Self>) -> _pyo3::PyResult<f64> {
                match &*slf.into_super() {
                    ComplexEnum::Float { f, .. } => Ok(f.clone()),
                    _ => {
                        ::core::panicking::panic_fmt(format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass"
                            )
                        ));
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ComplexEnum_Str {
            fn __pymethod_constructor__(py: _pyo3::Python<'_>, s: String) -> _pyo3::PyObject {
                use _pyo3::IntoPy;
                ComplexEnum::Str { s }.into_py(py)
            }
            fn s(slf: _pyo3::PyRef<Self>) -> _pyo3::PyResult<String> {
                match &*slf.into_super() {
                    ComplexEnum::Str { s, .. } => Ok(s.clone()),
                    _ => {
                        ::core::panicking::panic_fmt(format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass"
                            )
                        ));
                    }
                }
            }
        }
    };
    pub fn do_stuff(thing: &ComplexEnum) -> ComplexEnum {
        match thing {
            ComplexEnum::Int { i } => ComplexEnum::Str {
                s: {
                    let res = ::alloc::fmt::format(format_args!("{0}", i));
                    res
                },
            },
            ComplexEnum::Float { f } => ComplexEnum::Float { f: f * f },
            ComplexEnum::Str { s } => ComplexEnum::Int { i: s.len() as i32 },
        }
    }
    #[doc(hidden)]
    pub mod do_stuff {
        pub(crate) struct MakeDef;
        pub const DEF: ::pyo3::impl_::pyfunction::PyMethodDef = MakeDef::DEF;
    }
    const _: () = {
        use pyo3 as _pyo3;
        impl do_stuff::MakeDef {
            const DEF: ::pyo3::impl_::pyfunction::PyMethodDef =
                _pyo3::impl_::pymethods::PyMethodDef::fastcall_cfunction_with_keywords(
                    "do_stuff\0",
                    _pyo3::impl_::pymethods::PyCFunctionFastWithKeywords({
                        unsafe extern "C" fn trampoline(
                            _slf: *mut _pyo3::ffi::PyObject,
                            _args: *const *mut _pyo3::ffi::PyObject,
                            _nargs: _pyo3::ffi::Py_ssize_t,
                            _kwnames: *mut _pyo3::ffi::PyObject,
                        ) -> *mut _pyo3::ffi::PyObject {
                            _pyo3::impl_::trampoline::fastcall_with_keywords(
                                _slf,
                                _args,
                                _nargs,
                                _kwnames,
                                __pyfunction_do_stuff,
                            )
                        }
                        trampoline
                    }),
                    "do_stuff(thing)\n--\n\n\0",
                );
        }
        #[allow(non_snake_case)]
        unsafe fn __pyfunction_do_stuff<'py>(
            py: _pyo3::Python<'py>,
            _slf: *mut _pyo3::ffi::PyObject,
            _args: *const *mut _pyo3::ffi::PyObject,
            _nargs: _pyo3::ffi::Py_ssize_t,
            _kwnames: *mut _pyo3::ffi::PyObject,
        ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
            let function = do_stuff;
            const DESCRIPTION: _pyo3::impl_::extract_argument::FunctionDescription =
                _pyo3::impl_::extract_argument::FunctionDescription {
                    cls_name: ::std::option::Option::None,
                    func_name: "do_stuff",
                    positional_parameter_names: &["thing"],
                    positional_only_parameters: 0usize,
                    required_positional_parameters: 1usize,
                    keyword_only_parameters: &[],
                };
            let mut output = [::std::option::Option::None; 1usize];
            let (_args, _kwargs) =
                    DESCRIPTION.extract_arguments_fastcall::<_pyo3::impl_::extract_argument::NoVarargs,
                            _pyo3::impl_::extract_argument::NoVarkeywords>(py, _args,
                            _nargs, _kwnames, &mut output)?;
            _pyo3::impl_::wrap::OkWrap::wrap(
                function(_pyo3::impl_::extract_argument::extract_argument(
                    _pyo3::impl_::extract_argument::unwrap_required_argument(output[0usize]),
                    &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                    "thing",
                )?),
                py,
            )
            .map_err(::core::convert::Into::<_pyo3::PyErr>::into)
            .map(_pyo3::PyObject::into_ptr)
        }
    };
    pub enum DayOfTheWeek {
        Sunday,
        Monday,
        Tuesday,
        Wednesday,
        Thursday,
        Friday,
        Saturday,
    }
    const _: () = {
        use pyo3 as _pyo3;
        unsafe impl _pyo3::type_object::PyTypeInfo for DayOfTheWeek {
            type AsRefTarget = _pyo3::PyCell<Self>;
            const NAME: &'static str = "DayOfTheWeek";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(py: _pyo3::Python<'_>) -> *mut _pyo3::ffi::PyTypeObject {
                <DayOfTheWeek as _pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        impl _pyo3::PyClass for DayOfTheWeek {
            type Frozen = _pyo3::pyclass::boolean_struct::False;
        }
        impl<'a, 'py> _pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py> for &'a DayOfTheWeek {
            type Holder = ::std::option::Option<_pyo3::PyRef<'py, DayOfTheWeek>>;
            #[inline]
            fn extract(
                obj: &'py _pyo3::PyAny,
                holder: &'a mut Self::Holder,
            ) -> _pyo3::PyResult<Self> {
                _pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl<'a, 'py> _pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py> for &'a mut DayOfTheWeek {
            type Holder = ::std::option::Option<_pyo3::PyRefMut<'py, DayOfTheWeek>>;
            #[inline]
            fn extract(
                obj: &'py _pyo3::PyAny,
                holder: &'a mut Self::Holder,
            ) -> _pyo3::PyResult<Self> {
                _pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
            }
        }
        impl _pyo3::IntoPy<_pyo3::PyObject> for DayOfTheWeek {
            fn into_py(self, py: _pyo3::Python) -> _pyo3::PyObject {
                _pyo3::IntoPy::into_py(_pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        impl _pyo3::impl_::pyclass::PyClassImpl for DayOfTheWeek {
            const IS_BASETYPE: bool = false;
            const IS_SUBCLASS: bool = false;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type BaseType = _pyo3::PyAny;
            type ThreadChecker = _pyo3::impl_::pyclass::SendablePyClass<DayOfTheWeek>;
            type PyClassMutability =
                    <<_pyo3::PyAny as
                    _pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability
                    as _pyo3::impl_::pycell::PyClassMutability>::MutableChild;
            type Dict = _pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = _pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType = _pyo3::PyAny;
            fn items_iter() -> _pyo3::impl_::pyclass::PyClassItemsIter {
                use _pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[
                        _pyo3::class::PyMethodDefType::ClassAttribute({
                            _pyo3::class::PyClassAttributeDef::new(
                                { "Sunday\0" },
                                _pyo3::impl_::pymethods::PyClassAttributeFactory(
                                    DayOfTheWeek::__pymethod_Sunday__,
                                ),
                            )
                        }),
                        _pyo3::class::PyMethodDefType::ClassAttribute({
                            _pyo3::class::PyClassAttributeDef::new(
                                { "Monday\0" },
                                _pyo3::impl_::pymethods::PyClassAttributeFactory(
                                    DayOfTheWeek::__pymethod_Monday__,
                                ),
                            )
                        }),
                        _pyo3::class::PyMethodDefType::ClassAttribute({
                            _pyo3::class::PyClassAttributeDef::new(
                                { "Tuesday\0" },
                                _pyo3::impl_::pymethods::PyClassAttributeFactory(
                                    DayOfTheWeek::__pymethod_Tuesday__,
                                ),
                            )
                        }),
                        _pyo3::class::PyMethodDefType::ClassAttribute({
                            _pyo3::class::PyClassAttributeDef::new(
                                { "Wednesday\0" },
                                _pyo3::impl_::pymethods::PyClassAttributeFactory(
                                    DayOfTheWeek::__pymethod_Wednesday__,
                                ),
                            )
                        }),
                        _pyo3::class::PyMethodDefType::ClassAttribute({
                            _pyo3::class::PyClassAttributeDef::new(
                                { "Thursday\0" },
                                _pyo3::impl_::pymethods::PyClassAttributeFactory(
                                    DayOfTheWeek::__pymethod_Thursday__,
                                ),
                            )
                        }),
                        _pyo3::class::PyMethodDefType::ClassAttribute({
                            _pyo3::class::PyClassAttributeDef::new(
                                { "Friday\0" },
                                _pyo3::impl_::pymethods::PyClassAttributeFactory(
                                    DayOfTheWeek::__pymethod_Friday__,
                                ),
                            )
                        }),
                        _pyo3::class::PyMethodDefType::ClassAttribute({
                            _pyo3::class::PyClassAttributeDef::new(
                                { "Saturday\0" },
                                _pyo3::impl_::pymethods::PyClassAttributeFactory(
                                    DayOfTheWeek::__pymethod_Saturday__,
                                ),
                            )
                        }),
                    ],
                    slots: &[
                        {
                            unsafe extern "C" fn trampoline(
                                _slf: *mut _pyo3::ffi::PyObject,
                            ) -> *mut _pyo3::ffi::PyObject {
                                _pyo3::impl_::trampoline::reprfunc(
                                    _slf,
                                    DayOfTheWeek::__pymethod___default___pyo3__repr______,
                                )
                            }
                            _pyo3::ffi::PyType_Slot {
                                slot: _pyo3::ffi::Py_tp_repr,
                                pfunc: trampoline as _pyo3::ffi::reprfunc as _,
                            }
                        },
                        {
                            unsafe extern "C" fn trampoline(
                                _slf: *mut _pyo3::ffi::PyObject,
                            ) -> *mut _pyo3::ffi::PyObject {
                                _pyo3::impl_::trampoline::unaryfunc(
                                    _slf,
                                    DayOfTheWeek::__pymethod___default___pyo3__int______,
                                )
                            }
                            _pyo3::ffi::PyType_Slot {
                                slot: _pyo3::ffi::Py_nb_int,
                                pfunc: trampoline as _pyo3::ffi::unaryfunc as _,
                            }
                        },
                        {
                            unsafe extern "C" fn trampoline(
                                _slf: *mut _pyo3::ffi::PyObject,
                                arg0: *mut _pyo3::ffi::PyObject,
                                arg1: ::std::os::raw::c_int,
                            ) -> *mut _pyo3::ffi::PyObject {
                                _pyo3::impl_::trampoline::richcmpfunc(
                                    _slf,
                                    arg0,
                                    arg1,
                                    DayOfTheWeek::__pymethod___default___pyo3__richcmp______,
                                )
                            }
                            _pyo3::ffi::PyType_Slot {
                                slot: _pyo3::ffi::Py_tp_richcompare,
                                pfunc: trampoline as _pyo3::ffi::richcmpfunc as _,
                            }
                        },
                    ],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(py: _pyo3::Python<'_>) -> _pyo3::PyResult<&'static ::std::ffi::CStr> {
                use _pyo3::impl_::pyclass::*;
                static DOC: _pyo3::once_cell::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = _pyo3::once_cell::GILOnceCell::new();
                DOC.get_or_try_init(py, || {
                    let collector = PyClassImplCollector::<Self>::new();
                    build_pyclass_doc(
                        <DayOfTheWeek as _pyo3::PyTypeInfo>::NAME,
                        "\0",
                        ::std::option::Option::None.or_else(|| collector.new_text_signature()),
                    )
                })
                .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static _pyo3::impl_::pyclass::LazyTypeObject<Self> {
                use _pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<DayOfTheWeek> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl DayOfTheWeek {
            fn __pymethod_Sunday__(py: _pyo3::Python<'_>) -> _pyo3::PyResult<_pyo3::PyObject> {
                ::std::result::Result::Ok(_pyo3::IntoPy::into_py(DayOfTheWeek::Sunday, py))
            }
            fn __pymethod_Monday__(py: _pyo3::Python<'_>) -> _pyo3::PyResult<_pyo3::PyObject> {
                ::std::result::Result::Ok(_pyo3::IntoPy::into_py(DayOfTheWeek::Monday, py))
            }
            fn __pymethod_Tuesday__(py: _pyo3::Python<'_>) -> _pyo3::PyResult<_pyo3::PyObject> {
                ::std::result::Result::Ok(_pyo3::IntoPy::into_py(DayOfTheWeek::Tuesday, py))
            }
            fn __pymethod_Wednesday__(py: _pyo3::Python<'_>) -> _pyo3::PyResult<_pyo3::PyObject> {
                ::std::result::Result::Ok(_pyo3::IntoPy::into_py(DayOfTheWeek::Wednesday, py))
            }
            fn __pymethod_Thursday__(py: _pyo3::Python<'_>) -> _pyo3::PyResult<_pyo3::PyObject> {
                ::std::result::Result::Ok(_pyo3::IntoPy::into_py(DayOfTheWeek::Thursday, py))
            }
            fn __pymethod_Friday__(py: _pyo3::Python<'_>) -> _pyo3::PyResult<_pyo3::PyObject> {
                ::std::result::Result::Ok(_pyo3::IntoPy::into_py(DayOfTheWeek::Friday, py))
            }
            fn __pymethod_Saturday__(py: _pyo3::Python<'_>) -> _pyo3::PyResult<_pyo3::PyObject> {
                ::std::result::Result::Ok(_pyo3::IntoPy::into_py(DayOfTheWeek::Saturday, py))
            }
            unsafe fn __pymethod___default___pyo3__repr______(
                py: _pyo3::Python<'_>,
                _raw_slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                let function = DayOfTheWeek::__pyo3__repr__;
                let _slf = _raw_slf;
                _pyo3::callback::convert(
                    py,
                    DayOfTheWeek::__pyo3__repr__(
                        _pyo3::impl_::extract_argument::extract_pyclass_ref::<DayOfTheWeek>(
                            py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                            &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                        )?,
                    ),
                )
            }
            unsafe fn __pymethod___default___pyo3__int______(
                py: _pyo3::Python<'_>,
                _raw_slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                let function = DayOfTheWeek::__pyo3__int__;
                let _slf = _raw_slf;
                _pyo3::callback::convert(
                    py,
                    DayOfTheWeek::__pyo3__int__(
                        _pyo3::impl_::extract_argument::extract_pyclass_ref::<DayOfTheWeek>(
                            py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                            &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                        )?,
                    ),
                )
            }
            unsafe fn __pymethod___default___pyo3__richcmp______(
                py: _pyo3::Python<'_>,
                _raw_slf: *mut _pyo3::ffi::PyObject,
                arg0: *mut _pyo3::ffi::PyObject,
                arg1: ::std::os::raw::c_int,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                let function = DayOfTheWeek::__pyo3__richcmp__;
                let _slf = _raw_slf;
                _pyo3::callback::convert(
                    py,
                    DayOfTheWeek::__pyo3__richcmp__(
                        match _pyo3::impl_::extract_argument::extract_pyclass_ref::<DayOfTheWeek>(
                            py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                            &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                        ) {
                            ::std::result::Result::Ok(value) => value,
                            ::std::result::Result::Err(_) => {
                                return _pyo3::callback::convert(py, py.NotImplemented());
                            }
                        },
                        py,
                        match _pyo3::impl_::extract_argument::extract_argument(
                            py.from_borrowed_ptr::<_pyo3::PyAny>(arg0),
                            &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                            "other",
                        ) {
                            ::std::result::Result::Ok(value) => value,
                            ::std::result::Result::Err(_) => {
                                return _pyo3::callback::convert(py, py.NotImplemented());
                            }
                        },
                        match _pyo3::class::basic::CompareOp::from_raw(arg1).ok_or_else(|| {
                            _pyo3::exceptions::PyValueError::new_err("invalid comparison operator")
                        }) {
                            ::std::result::Result::Ok(value) => value,
                            ::std::result::Result::Err(_) => {
                                return _pyo3::callback::convert(py, py.NotImplemented());
                            }
                        },
                    ),
                )
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl DayOfTheWeek {
            fn __pyo3__repr__(&self) -> &'static str {
                match self {
                    DayOfTheWeek::Sunday => "DayOfTheWeek.Sunday",
                    DayOfTheWeek::Monday => "DayOfTheWeek.Monday",
                    DayOfTheWeek::Tuesday => "DayOfTheWeek.Tuesday",
                    DayOfTheWeek::Wednesday => "DayOfTheWeek.Wednesday",
                    DayOfTheWeek::Thursday => "DayOfTheWeek.Thursday",
                    DayOfTheWeek::Friday => "DayOfTheWeek.Friday",
                    DayOfTheWeek::Saturday => "DayOfTheWeek.Saturday",
                }
            }
            fn __pyo3__int__(&self) -> isize {
                match self {
                    DayOfTheWeek::Sunday => DayOfTheWeek::Sunday as isize,
                    DayOfTheWeek::Monday => DayOfTheWeek::Monday as isize,
                    DayOfTheWeek::Tuesday => DayOfTheWeek::Tuesday as isize,
                    DayOfTheWeek::Wednesday => DayOfTheWeek::Wednesday as isize,
                    DayOfTheWeek::Thursday => DayOfTheWeek::Thursday as isize,
                    DayOfTheWeek::Friday => DayOfTheWeek::Friday as isize,
                    DayOfTheWeek::Saturday => DayOfTheWeek::Saturday as isize,
                }
            }
            fn __pyo3__richcmp__(
                &self,
                py: _pyo3::Python,
                other: &_pyo3::PyAny,
                op: _pyo3::basic::CompareOp,
            ) -> _pyo3::PyResult<_pyo3::PyObject> {
                use _pyo3::conversion::ToPyObject;
                use core::result::Result::*;
                match op {
                    _pyo3::basic::CompareOp::Eq => {
                        let self_val = self.__pyo3__int__();
                        if let Ok(i) = other.extract::<isize>() {
                            return Ok((self_val == i).to_object(py));
                        }
                        if let Ok(other) = other.extract::<_pyo3::PyRef<Self>>() {
                            return Ok((self_val == other.__pyo3__int__()).to_object(py));
                        }
                        return Ok(py.NotImplemented());
                    }
                    _pyo3::basic::CompareOp::Ne => {
                        let self_val = self.__pyo3__int__();
                        if let Ok(i) = other.extract::<isize>() {
                            return Ok((self_val != i).to_object(py));
                        }
                        if let Ok(other) = other.extract::<_pyo3::PyRef<Self>>() {
                            return Ok((self_val != other.__pyo3__int__()).to_object(py));
                        }
                        return Ok(py.NotImplemented());
                    }
                    _ => Ok(py.NotImplemented()),
                }
            }
        }
    };
}
